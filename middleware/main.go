package main

import (
	"flag"
	"log"
	"os"
	"time"
)

var (
	applicationConfigFile = "/etc/csp-connector/config.json"
	currentJsonValue      = unmarshalJSONIntoStruct([]byte(readFileAndReturnAsBytes(applicationConfigFile)), &AutoGenerated{})
	// Note: Future update for now we are using a temp bool var
	// rtspServerStatusChannel = make(map[string]bool)
	rtspServerOneStatus bool
	debug bool
)

// The layout for the json stuff.
type AutoGenerated struct {
	Num0 struct {
		Host                      string `json:"host"`
		AmazonKinesisVideoStreams struct {
			AwsAccessKeyID     string `json:"aws_access_key_id"`
			AwsSecretAccessKey string `json:"aws_secret_access_key"`
			AwsDefaultRegion   string `json:"aws_default_region"`
			KinesisStream      string `json:"kinesis_stream"`
		} `json:"amazon_kinesis_video_streams"`
		GoogleCloudVertexAiVision struct {
			ProjectName   string `json:"project_name"`
			GcpRegion     string `json:"gcp_region"`
			VertexStreams string `json:"vertex_streams"`
		} `json:"google_cloud_vertex_ai_vision"`
	} `json:"0"`
}

func init() {
	// Check if there are any user provided flags in the request.
	if len(os.Args) > 1 {
		// Check if the config path is provided.
		tempConfig := flag.String("config", "/etc/csp-connector/config.json", "The location of the config file.")
		tempDebug := flag.Bool("debug", false, "Determine if this is a debug run.")
		flag.Parse()
		applicationConfigFile = *tempConfig
		debug = *tempDebug
	} else {
		// if there are no flags provided than we close the application.
		log.Fatalln("Error: No flags provided. Please use -help for more information.")
	}
	// Check if the config file exists in the current directory
	if fileExists(applicationConfigFile) == false {
		// Write a config file in the current directory if it doesn't exist
		writeToFile(applicationConfigFile, []byte(encodeStructToJSON(AutoGenerated{})))
		// Exit the application since the config file was written just now and content will not be in that file.
		exitTheApplication("Error: Just created the default configuration; please edit the configuration and launch the program again.")
	}
	// Print the sha256 of the file
	// log.Println(sha256OfFile(applicationConfigFile))
	// Check if the config file has not been modified
	if sha256OfFile(applicationConfigFile) == "ccc102b45cfe689069ba0322547d286b6997cca1f221ab748ed9f2c139e0f19ea33b807a735dfd5c5af900abb395901398410e7a3d6558189f26ce66041349a7" {
		// The file has not been modified
		exitTheApplication("Error: The config file has not been modified, Please modify it and try again.")
	}
	// Can check for rtsp server but
	// what u can easily do is run rtsp server on one server and run this on another server.
	// The list of app required for this to work.
	// kensis // google cloud vision ai.
	requiredApplications := []string{"vaictl"}
	// Check if the required application are present in the system
	for _, app := range requiredApplications {
		if commandExists(app) == false {
			exitTheApplication("Error: " + app + "is not installed in your system, Please install it and try again.")
		}
	}
	// Check if the config has the correct format and all the info is correct.
	if jsonValid(readFileAndReturnAsBytes(applicationConfigFile)) == false {
		exitTheApplication("Error: The config file is not a valid json file.")
	}
	// Make sure the length of the json is not 0
	if len(currentJsonValue.(*AutoGenerated).Num0.Host) == 0 {
		exitTheApplication("Error: The host value is not set in the config file.")
	}
	// Make sure non of the values are deafult; if it is than exit.

	// Validate all the data thats imported in the app; test run the connection if possible.

	// Check if the rtsp server is alive and responding to requests
	go checkRTSPServerAliveInBackground(currentJsonValue.(*AutoGenerated).Num0.Host)
}

func main() {
	// RTSP Connection Counter
	log.Println("We are outside the loop, about to start the loop")
	rtspConnectionCounter := 0
	for {
		log.Println("We are inside the loop")
		// Check the ammount of time the rtsp server has run
		if rtspConnectionCounter == 0 {
			log.Println(rtspServerOneStatus)
			log.Println("We got the status of the rtsp server.")
			// Check if the rtsp server is alive and responding to requests; run the upload in the background
			if rtspServerOneStatus {
				log.Println("The rtsp server is alive and we are about to start the upload.")
				// Add a 1 to the counter
				rtspConnectionCounter = rtspConnectionCounter + 1
				// Upload the feed into AWS Kinesis Video Streams
				runGstPipeline(currentJsonValue.(*AutoGenerated).Num0.Host, currentJsonValue.(*AutoGenerated).Num0.AmazonKinesisVideoStreams.KinesisStream, currentJsonValue.(*AutoGenerated).Num0.AmazonKinesisVideoStreams.AwsAccessKeyID, currentJsonValue.(*AutoGenerated).Num0.AmazonKinesisVideoStreams.AwsSecretAccessKey, currentJsonValue.(*AutoGenerated).Num0.AmazonKinesisVideoStreams.AwsDefaultRegion)
				log.Println("We are writing to the aws kinesis video streams.")
				// Note temp work around
				// mv /etc/amazon-kinesis-video-streams-producer-sdk-cpp/build/libgstkvssink.so /etc/amazon-kinesis-video-streams-producer-sdk-cpp/build/libgstkvssink.so.tmp
				// This is a temp work around for the issue with the kinesis video streams, Once your done with the upload you can move the file back to its original location.
				// mv /etc/amazon-kinesis-video-streams-producer-sdk-cpp/build/libgstkvssink.so.tmp /etc/amazon-kinesis-video-streams-producer-sdk-cpp/build/libgstkvssink.so
				// Upload the feed into Google cloud vertex AI
				// forwardDataToGoogleCloudVertexAI(currentJsonValue.(*AutoGenerated).Num0.Host, currentJsonValue.(*AutoGenerated).Num0.GoogleCloudVertexAiVision.ProjectName, currentJsonValue.(*AutoGenerated).Num0.GoogleCloudVertexAiVision.GcpRegion, currentJsonValue.(*AutoGenerated).Num0.GoogleCloudVertexAiVision.VertexStreams)
				// Docs: Upload mock test data.
				log.Println("We are about to remove a 1 from the counter.")
				// Remove a 1 from the counter when the upload is done
				rtspConnectionCounter = rtspConnectionCounter - 1
			}
		}
		// Sleep for 5 seconds
		time.Sleep(5 * time.Second)
		// debug
		if debug {
			log.Println("Debug session, ending now")
			os.Exit(0)
		}
	}
}
