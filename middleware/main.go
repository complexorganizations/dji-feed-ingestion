package main

import (
	"context"
	"flag"
	"log"
	"os"
	"reflect"
	"strconv"
	"sync"
	"time"
)

var (
	// The location for the config file for the application to use.
	applicationConfigFile = getCurrentWorkingDirectory() + "config.json"
	// The location for the log file for the application to use.
	applicationLogFile         = getCurrentWorkingDirectory() + "log.txt"
	currentJsonValue           interface{}
	// RTSP Server Status Channel
	rtspServerStatusChannel    = make(map[string]bool)
	// RTSP Server Streaming Channel
	rtspServerStreamingChannel = make(map[string]bool)
	// RTSP Server Packet Channel
	rtspServerPacketChannel    = make(map[string]bool)
	// Debug
	debug                      bool
	// AWS KVS
	awsKVS                     bool
	// GCP
	gcp                        bool
	// Google Cloud Credentials
	googleCloudCredentials = currentUserHomeDir() + "/.config/gcloud/application_default_credentials.json"
	// Number of clients allowed on the system.
	numberOfClientsAllowed int
)

// The config file struct for the application to use.
type AutoGenerated struct {
	Num0  HostStruct `json:"0"`
	Num1  HostStruct `json:"1"`
	Num2  HostStruct `json:"2"`
	Num3  HostStruct `json:"3"`
	Num4  HostStruct `json:"4"`
}

// The host struct for the application to use.
type HostStruct struct {
	Host                          string                        `json:"host"`
	AmazonKinesisVideoStreams     AmazonKinesisVideoStreams     `json:"amazon_kinesis_video_streams"`
	GoogleCloudVertexAiVision     GoogleCloudVertexAiVision     `json:"google_cloud_vertex_ai_vision"`
}

// The Amazon Kinesis Video Streams struct for the application to use.
type AmazonKinesisVideoStreams struct {
	DefaultRegion string `json:"default_region"`
	KinesisStream string `json:"kinesis_stream"`
}

// The Google Cloud Vertex AI Vision struct for the application to use.
type GoogleCloudVertexAiVision struct {
	ProjectName          string `json:"project_name"`
	DefaultRegion        string `json:"default_region"`
	VertexAiVisionStream string `json:"vertex_ai_vision_stream"`
}

func init() {
	// Validate the operating system
	lockdownToLinuxOperatingSystem()
	// Check if there are any user provided flags in the request.
	if len(os.Args) > 1 {
		// Check if the config path is provided.
		tempConfig := flag.String("config", "config.json", "The location of the config file.")
		tempLog := flag.String("log", "log.txt", "The location of the log file.")
		tempDebug := flag.Bool("debug", false, "Determine if this is a debug run.")
		tempAWSKVS := flag.Bool("aws_kvs", false, "Determine if this is a AWS run.")
		tempGCP := flag.Bool("gcp", false, "Determine if this is a GCP run.")
		flag.Parse()
		// Set the values to the global variables.
		applicationConfigFile = *tempConfig
		applicationLogFile = *tempLog
		debug = *tempDebug
		awsKVS = *tempAWSKVS
		gcp = *tempGCP
	} else {
		// if there are no flags provided than we close the application.
		log.Fatalln("Error: No flags provided. Please use -help for more information.")
	}
	// Only run one of the three options.
	if awsKVS && gcp {
		log.Fatalln("Error: You can only run one of the -help options.")
	}
	// Check if the system has the required tools and is installed in path.
	requiredApplications := []string{
		"vaictl",
		"gst-launch-1.0",
		"ffmpeg",
		"aws",
		"gcloud",
	}
	// Check if the required application are present in the system
	for _, app := range requiredApplications {
		if !commandExists(app) {
			saveAllErrors("Error: " + app + "is not installed in your system, Please install it and try again.")
		}
	}
	// Check if the config file exists in the current directory
	if !fileExists(applicationConfigFile) {
		// Write a config file in the current directory if it doesn't exist
		writeToFile(applicationConfigFile, []byte(encodeStructToJSON(AutoGenerated{})))
		// Exit the application since the config file was written just now and content will not be in that file.
		saveAllErrors("Error: Just created the default configuration; please edit the configuration and launch the program again.")
	}
	// Check if the file provided has a valid .json extension.
	if getFileExtension(applicationConfigFile) != ".json" {
		saveAllErrors("Error: The extension of the config file isn't valid.")
	}
	// DEBUG: Print the Hash of the file to change it below.
	// log.Println(sha256OfFile(applicationConfigFile))
	// Hash the file and get the SHA-256 and make sure its not the deafult config.
	if sha256OfFile(applicationConfigFile) == "7f6b889e1e2f5dbbbf4c44b36c875de4a6ed6310f3533ebdaefbeed5e5fb10107f8526b1b068feadfab5966f04d398314f444b749c2e5e7c42171c22800b5753" {
		// The file has not been modified
		saveAllErrors("Error: The config file has not been modified, Please modify it and try again.")
	}
	// Check if the config has the correct format and all the info is correct.
	if !jsonValid(readFileAndReturnAsBytes(applicationConfigFile)) {
		saveAllErrors("Error: The config file is not a valid json file.")
	}
	// Read the config file and store it in a variable
	currentJsonValue = unmarshalJSONIntoStruct([]byte(readFileAndReturnAsBytes(applicationConfigFile)), &AutoGenerated{})
	// Get the lenth of the struct; this will be the number of servers.
	numberOfHosts := reflect.TypeOf(AutoGenerated{})
	numberOfClientsAllowed = numberOfHosts.NumField()
	// Checks how many hosts are in the config file and than determines if the app will allow it.
	if countHosts() >= numberOfClientsAllowed {
		log.Fatalln("Warning: The number of servers in the config file is more than the number of servers in the struct.")
	}
	// Get the real number of servers in the config file.
	numberOfClientsAllowed = countHosts()
	// RTSP Server Counter Map.
	for i := 0; i < numberOfClientsAllowed; i++ {
		server := getServerByIndex(currentJsonValue.(*AutoGenerated), i)
		// Validate the length of the config file
		validateJSONLength("Host", server.Host)
		// AWS KVS
		validateJSONLength("Amazon Kinesis Region", server.AmazonKinesisVideoStreams.DefaultRegion)
		validateJSONLength("Amazon Kinesis Stream Name", server.AmazonKinesisVideoStreams.KinesisStream)
		// GCP
		validateJSONLength("Google Project Name", server.GoogleCloudVertexAiVision.ProjectName)
		validateJSONLength("Google Default Region", server.GoogleCloudVertexAiVision.DefaultRegion)
		validateJSONLength("Google Vertex AI Vision Stream", server.GoogleCloudVertexAiVision.VertexAiVisionStream)
		// Check if the rtsp server is alive and responding to requests
		go checkRTSPServerAliveInBackground(server.Host)
		// Check if the rtsp server is sending packets
		go checkRTSPStreamPacketConnectionInLoop(server.Host)
	}
	// Note: This is a temp location for this and other location will be better for this.
	go checkConfigChanges()
	// Validate the content of the config file (API Keys, etc.)
}

func main() {
	// Setup the variables for aws.
	var accessKey string
	var secretKey string
	if awsKVS {
		// Get the AWS Credentials
		accessKey, secretKey = parseAWSCredentialsFile()
	} else if gcp {
		// Get the Google Cloud Credentials
		validateGoogleCloudCLI()
	}
	// Create a wait group for the upload
	var uploadWaitGroup sync.WaitGroup
	// Create a counter map for the RTSP Server
	var rtspServerRunCounter = make(map[string]int)
	// Var counter
	var counter int
	// Create a map for the cancel functions
	var cancelFuncs = make(map[string]context.CancelFunc)
	// Always Check for updates
	for {
		// Check for updates from each server
		for i := 0; i < numberOfClientsAllowed; i++ {
			// Start the cancel and the context for the RTSP Server
			ctx, cancel := context.WithCancel(context.Background())
			// Get the server from the config file
			server := getServerByIndex(currentJsonValue.(*AutoGenerated), i)
			// Make sure the server isnt already streaming the feed.
			if !getValueFromMap(rtspServerStreamingChannel, server.Host) {
				log.Println("Server isnt streaming the feed from the " + server.Host)
				// Make sure you only run the server once.
				if rtspServerRunCounter[server.Host] == 0 {
					// Prevent the server from running again if it is already running
					rtspServerRunCounter[server.Host] = 1
					// Check if the server is alive and responding to requests
					if getValueFromMap(rtspServerStatusChannel, server.Host) && getValueFromMap(rtspServerPacketChannel, server.Host) {
						log.Println("We are going to forward the feed from the " + server.Host)
						// Add key-value pair to the map
						cancelFuncs[server.Host] = cancel
						// Increment the counter
						counter = counter + 1
						// Add one to the wait group
						uploadWaitGroup.Add(1)
						// Start uploading the feed in the background.
						if awsKVS {
							go forwardDataToAmazonKinesisStreams(server.Host, server.AmazonKinesisVideoStreams.KinesisStream, accessKey, secretKey, server.AmazonKinesisVideoStreams.DefaultRegion, &uploadWaitGroup, ctx)
						} else if gcp {
							go forwardDataToGoogleCloudVertexAI(server.Host, server.GoogleCloudVertexAiVision.ProjectName, server.GoogleCloudVertexAiVision.DefaultRegion, server.GoogleCloudVertexAiVision.VertexAiVisionStream, &uploadWaitGroup, ctx)
						}
					} else {
						log.Println("Server is not alive: " + server.Host)
						log.Println("Server is not sending packets: " + server.Host)
					}
					rtspServerRunCounter[server.Host] = 0
				}
			} else {
				log.Println("Server is already streaming: " + server.Host)
			}
			// Task: Cancel the context if the server is not alive.
			// Check if there is a upload in progress.
			if getValueFromMap(rtspServerStreamingChannel, server.Host) {
				// Check if the server is alive and responding to requests
				if !getValueFromMap(rtspServerStatusChannel, server.Host) {
					log.Println("Canceling the context for: " + server.Host + " because the server is not alive.")
					// Cancel the context
					cancelFuncs[server.Host]()
				}
				// Check if the packet connection is alive
				if !getValueFromMap(rtspServerPacketChannel, server.Host) {
					log.Println("Canceling the context for: " + server.Host + " because the server is not sending packets.")
					// Cancel the context
					cancelFuncs[server.Host]()
				}
			}
			// Debug
			log.Println("Current forwarding status map: ", rtspServerStreamingChannel)
		}
		// This sleep determins how often the program checks if the RTSP server is alive and streaming.
		time.Sleep(5 * time.Second)
		// The counter for how many streams are being uploaded.
		log.Println("Count how many times the stream has been forwarded so far: " + strconv.Itoa(counter))
		// End if debug
		if debug {
			break
		}
	}
	// Wait for the upload to finish
	uploadWaitGroup.Wait()
}
